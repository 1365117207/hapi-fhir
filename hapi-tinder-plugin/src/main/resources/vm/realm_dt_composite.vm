#parse ( "/vm/realm_templates.vm" )

package ${packageBase}.composite;

import java.net.URI;
import java.math.BigDecimal;
import org.apache.commons.lang3.StringUtils;
import java.util.*;
import ca.uhn.fhir.model.api.*;
import ca.uhn.fhir.model.primitive.*;
import ca.uhn.fhir.model.api.annotation.*;
import ca.uhn.fhir.model.base.composite.*;

import io.realm.RealmObject;

#foreach ( $import in $imports )
import ${import};
#end

/**
 * HAPI/FHIR <b>${className}</b> Datatype
 * (${shortName})
 *
 * <p>
 * <b>Definition:</b>
 * ${definition}
 * </p> 
 *
 * <p>
 * <b>Requirements:</b>
 * ${requirements}
 * </p> 
 */
@DatatypeDef(name="${elementName}") 
public class ${className}
        extends RealmObject 
        implements ICompositeDatatype#{if}(${className}=="MetaDt"), org.hl7.fhir.instance.model.api.IBaseMetaType #{end}#{if}(${className}=="CodingDt"), org.hl7.fhir.instance.model.api.IBaseCoding #{end} 
{

	/**
	 * Constructor
	 */
	public ${className}() {
		// nothing
	}


#if ( ${className} == "MetaDt" )
	@Override
	public MetaDt setLastUpdated(Date theHeaderDateValue) {
		return setLastUpdated(theHeaderDateValue, TemporalPrecisionEnum.SECOND);
	}

	/**
 	 * Returns the first tag (if any) that has the given system and code, or returns
 	 * <code>null</code> if none
 	 */
 	public CodingDt getTag(String theSystem, String theCode) {
 		for (CodingDt next : getTag()) {
 			if (ca.uhn.fhir.util.ObjectUtil.equals(next.getSystem(), theSystem) && ca.uhn.fhir.util.ObjectUtil.equals(next.getCode(), theCode)) {
 				return next;
 			}
 		}
 		return null;
 	}

 	/**
 	 * Returns the first security label (if any) that has the given system and code, or returns
 	 * <code>null</code> if none
 	 */
 	public CodingDt getSecurity(String theSystem, String theCode) {
 		for (CodingDt next : getTag()) {
 			if (ca.uhn.fhir.util.ObjectUtil.equals(next.getSystem(), theSystem) && ca.uhn.fhir.util.ObjectUtil.equals(next.getCode(), theCode)) {
 				return next;
 			}
 		}
 		return null;
 	}  

#end
#if ( ${className} == "ResourceReferenceDt" )
	/**
	 * Constructor which creates a resource reference containing the actual resource in question.
	 * <p>
	 * <b> When using this in a server:</b> Generally if this is serialized, it will be serialized as a contained
	 * resource, so this should not be used if the intent is not to actually supply the referenced resource. This is not
	 * a hard-and-fast rule however, as the server can be configured to not serialized this resource, or to load an ID
	 * and contain even if this constructor is not used.
	 * </p>
	 * 
	 * @param theResource
	 *            The resource instance
	 */
	public ResourceReferenceDt(IResource theResource) {
		super(theResource);
	}

	/**
	 * Constructor which accepts a reference directly (this can be an ID, a partial/relative URL or a complete/absolute
	 * URL)
	 * 
	 * @param theId
	 *            The reference itself
	 */
	public ResourceReferenceDt(String theId) {
		setReference(new IdDt(theId));
	}

	/**
	 * Constructor which accepts a reference directly (this can be an ID, a partial/relative URL or a complete/absolute
	 * URL)
	 * 
	 * @param theId
	 *            The reference itself
	 */
	public ResourceReferenceDt(org.hl7.fhir.instance.model.api.IIdType theResourceId) {
		setReference(theResourceId);
	}
#end

#childExtensionFields( $childExtensionTypes )
#childVars( $children )
#childAccessors( $children )
#childResourceBlocks($resourceBlockChildren)

#########################
### Type-specific methods
#########################
#if ( ${className} == "HumanNameDt" )
#end
#childExtensionTypes( $childExtensionTypes )



	@Override
	public boolean hasFormatComment() {
		return false;
	}

	@Override
	public List<String> getFormatCommentsPre() {
		return null;
	}

	@Override
	public List<String> getFormatCommentsPost() {
		return null;
	}

	@Override
	public <T extends IElement> List<T> getAllPopulatedChildElementsOfType(Class<T> theType) {
		return null;
	}



}